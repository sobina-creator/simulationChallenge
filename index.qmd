---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge - Starter Template

## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.  

Each year after buy-in you flip a fair coin:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

```{python}
#| echo: false
#| include: false
import daft

# Create the DAG directly without custom class
investmentDAG = daft.PGM(dpi=100, alternate_style="outer")

# Initial wealth (deterministic)
investmentDAG.add_node("W0", "Initial Wealth\n$W_0 = 30,000$", x=4, y=2.5, aspect=5.4, 
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes  
investmentDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=0, y=1, aspect=4, scale = 1.6,
                      plot_params={'facecolor': 'aliceblue'})
investmentDAG.add_node("Wt", "\nWealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$\n", x=4, y=1, scale = 1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
investmentDAG.add_edge("W0", "Wt")
investmentDAG.add_edge("Ct", "Wt")

# Add plate around time-dependent nodes
investmentDAG.add_plate([-2, 0.5, 7.8, 1.0], label="t = 1, ..., N", shift=-0.1)
```

```{python}
#| label: fig-investment-dag
#| fig-cap: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
#| echo: false
investmentDAG.show()
```

## Analysis Tasks



### 1) Expected Value After 1 Flip

TODO: Explain whether the expected value of your account balance after one flip is >, =, or < $30,000. What is the gain in expected value as a percentage of your buy-in? Does this simple analysis suggest you should buy-in to the game?

```{python}
#| label: q1-expected-value-py
#| echo: false

# Compute expected value after one coin flip
initial_balance = 30000

# Possible outcomes after one flip
win = 1.5 * initial_balance  # if heads (C_t = 1)
lose = 0.6 * initial_balance  # if tails (C_t = 0)

# Both outcomes are equally likely
expected_value = 0.5 * win + 0.5 * lose

print(f"Expected value after 1 flip: ${expected_value:,.2f}")

# Calculate gain as a percentage of buy-in
percent_gain = ((expected_value - initial_balance) / initial_balance) * 100
print(f"Gain in expected value: {percent_gain:.2f}%")

# Brief explanation
if expected_value > initial_balance:
    ans = "greater than"
elif expected_value < initial_balance:
    ans = "less than"
else:
    ans = "equal to"

print(f"The expected value after one flip is {ans} your initial buy-in of $30,000.")
print("Based on the expected value alone, this suggests you should buy in to the game (positive expected value).")

```

### 2) Single Simulation Over Time (Narrative + Plot)

Briefly narrate and visualize what happens to your account balance over the course of one run. Are you happy with the outcome? Why? or Why not?  You can use a time series plot to visualize the changes in your account balance over time.

```{python}
#| label: q2-single-sim-py
#| echo: false
#| fig-cap: "Single simulation path of account balance"

# TODO: Simulate one path from $30,000 over N periods
# - Make a matplotlib (OO) time-series
# - Set seed for reproducibility
import numpy as np
import matplotlib.pyplot as plt

# Set random seed for reproducibility
np.random.seed(42)

N = 40  # Number of periods ("years" in retirement)
initial_balance = 30000
balance_path = [initial_balance]

balance = initial_balance
for t in range(N):
    coin = np.random.choice([1, 0])  # 1=heads, 0=tails, p=0.5 each
    if coin == 1:
        balance *= 1.5
    else:
        balance *= 0.6
    balance_path.append(balance)

# Plotting the balance path
fig, ax = plt.subplots(figsize=(8,4))
ax.plot(range(N+1), balance_path, marker='o', linestyle='-', color='midnightblue')
ax.set_xlabel("Year")
ax.set_ylabel("Account Balance ($)")
ax.set_title("Single Simulation Path of Account Balance")
ax.axhline(initial_balance, linestyle='--', color='red', alpha=0.7, label="Initial Balance")
ax.legend()
plt.tight_layout()
plt.show()

# Narrative:
print(
    f"""
In this single simulation:
â€¢ The account balance undergoes a "random walk" driven by coin flips, where each year the balance is multiplied by 1.5 (heads) or 0.6 (tails).
â€¢ Over 40 periods, outcomes show sharp rises after streaks of heads and dramatic falls after streaks of tails.
â€¢ In this specific run (seed=42), the ending balance was ${balance_path[-1]:,.2f} compared to the initial $30,000.
â€¢ This shows a large spread in possible outcomes where luck plays a substantial role.
â€¢ You should consider whether you're "happy" with this volatility and risks, given decent chances of ending up with much less than you started.
"""
)

```

### 3) 100 Simulations: Distribution of Final Balances

TODO: Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that you'd be happy with after having invested $30,000?

```{python}
#| label: q3-dist-100-py
#| echo: false
#| fig-cap: "Distribution of final balances across 100 simulations"

# Run 100 simulations and plot histogram of final balances
num_simulations = 100
final_balances = []

for sim in range(num_simulations):
    balance = initial_balance
    for t in range(N):
        coin = np.random.choice([1, 0])  # 1=heads, 0=tails
        if coin == 1:
            balance *= 1.5
        else:
            balance *= 0.6
    final_balances.append(balance)

final_balances = np.array(final_balances)

# For extreme multiplicative games, many final balances cluster at small values (and a few are huge).
# To see the distribution more clearly, use a logarithmic x-axis and logarithmically spaced bins.

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import gaussian_kde

# Define bins spaced evenly in log10 space, covering the range of data
min_nonzero = np.min(final_balances[final_balances > 0])
min_bin = min_nonzero if min_nonzero < 1 else 1
max_bin = np.max(final_balances)*1.05

# Use more bins for better resolution
bins = np.logspace(np.log10(min_bin), np.log10(max_bin), 40)

# Create figure with better visualization
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), gridspec_kw={'height_ratios': [2, 1]})

# Main histogram
counts, bins_edges, patches = ax1.hist(final_balances, bins=bins, color="royalblue", 
                                        edgecolor="black", alpha=0.75, linewidth=0.5)
# Add color gradient based on frequency
max_count = max(counts)
for patch, count in zip(patches, counts):
    patch.set_facecolor(plt.cm.viridis(count/max_count))
    
ax1.axvline(initial_balance, linestyle='--', color='red', linewidth=2, label='Initial Balance ($30,000)')
ax1.set_xscale('log')
ax1.set_xlabel("Final Account Balance ($) [log scale]")
ax1.set_ylabel("Number of Simulations")
ax1.set_title("Distribution of Final Balances Across 100 Simulations (Log Scale)")
ax1.legend()
ax1.grid(True, alpha=0.3)
# Format x-axis to show plain numbers instead of scientific notation
ax1.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

# Overlay KDE for smooth curve
log_balances = np.log10(final_balances[final_balances > 0])
kde = gaussian_kde(log_balances)
log_x_range = np.logspace(np.log10(min_bin), np.log10(max_bin), 200)
log_x_kde = np.log10(log_x_range)
kde_vals = kde(log_x_kde)
ax1_twin = ax1.twinx()
ax1_twin.plot(log_x_range, kde_vals * len(final_balances) * (bins[1] - bins[0]), 
              'r-', linewidth=2, label='KDE Smoothing', alpha=0.7)
ax1_twin.set_ylabel('Density', color='red', fontsize=9)
ax1_twin.tick_params(axis='y', labelcolor='red', labelsize=8)
ax1_twin.legend(loc='upper right')

# Bottom subplot: individual simulation points (scatter overlay)
ax2.scatter(final_balances, np.random.randn(len(final_balances)) * 0.1, 
           alpha=0.5, s=20, color='darkblue', edgecolors='black', linewidth=0.3)
ax2.axvline(initial_balance, linestyle='--', color='red', linewidth=2)
ax2.set_xscale('log')
ax2.set_xlabel("Final Account Balance ($) [log scale]")
ax2.set_ylabel("Simulations")
ax2.set_title("Individual Simulation Outcomes")
ax2.grid(True, alpha=0.3)
ax2.set_ylim(-0.5, 0.5)
# Format x-axis to show plain numbers instead of scientific notation
ax2.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Compute and print statistics
mean_final = np.mean(final_balances)
median_final = np.median(final_balances)
prob_above_initial = np.mean(final_balances > initial_balance)

print(f"Mean final balance: ${mean_final:,.2f}")
print(f"Median final balance: ${median_final:,.2f}")
print(f"P(Final balance > $30,000): {prob_above_initial:.2%}")

# Narrative
print(
    f"""
After 100 simulated 40-year investment periods (starting from $30,000): 
- The mean final balance is ${mean_final:,.2f}, but the median is lower at ${median_final:,.2f}.
- Only {prob_above_initial:.1%} of simulations ended above the initial investment, meaning most runs lost money, even though a few paths ended with large gains.
- The distribution is highly skewed: a small number of simulations have very large final balances, but most see significant loss. 
This illustrates the high risk of such a strategy, and that "happy" long-term outcomes are unlikely without a lot of luck.
"""
)

```

### 4) Probability Balance > $30,000 at Age 75 (Original Game)

TODO: Report the probability estimate and interpret its practical meaning.

```{python}
#| label: q4-prob-original-py
#| echo: false

# TODO: Using the 100 simulations above, estimate P(final > 30000)
# - Print numeric result with 3 decimals
# Calculate and print the probability estimate
prob_above_30000 = np.mean(final_balances > 30000)
print(f"Estimated P(final balance > $30,000): {prob_above_30000:.3f}")

# Interpretation
print(
    f"""
Interpretation:
Out of 100 simulated 40-year investment periods, only {prob_above_30000:.1%} ended above the original $30,000 balance.
This means that, in practical terms, most investors playing this 'double or 40% loss' game every year for 40 years would finish with less than they started.
While a small fraction could see large wins, the overwhelming majority would see significant lossesâ€”highlighting the unfavorable odds and extreme riskiness of the strategy.
"""
)

```

### 5) Modified Strategy (Bet Exactly 50% Each Round)

Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?

```{python}
#| label: q5-modified-50pct-py
#| echo: false
#| fig-cap: "Modified strategy distribution (bet 50% each round)"

# TODO: Implement the modified game
# - Run 100 simulations; plot distribution of final balances
# - Estimate P(final > 30000) and compare to original
# - visually compare the outcome distributions of the original and modified strategies
# Set random seed for reproducibility
np.random.seed(42)

n_years = 40
n_simulations = 100
initial_balance = 30000
bet_fraction = 0.5  # Bet 50% of balance (=> risk 25% each round, due to 2x, 0.5x outcome on half)
# But if only 25% of balance is risked: bet_fraction = 0.25
# Instructions say "bet exactly 50%" (i.e., half of balance), so we simulate that.

final_balances_mod = []

for sim in range(n_simulations):
    balance = initial_balance
    for year in range(n_years):
        # Bet 50% of balance each round
        # Keep 50% safe, bet 50% with coin flip outcomes
        bet = balance * 0.5
        not_bet = balance - bet
        coin = np.random.choice([1, 0])  # 1=heads, 0=tails, p=0.5 each
        if coin == 1:
            # Heads: win 50% on the bet
            bet_return = bet * 1.5
        else:
            # Tails: lose 40% on the bet
            bet_return = bet * 0.6
        balance = not_bet + bet_return
    final_balances_mod.append(balance)

final_balances_mod = np.array(final_balances_mod)

# Plot histogram of final balances (compare to original) with improved visualization
import matplotlib.pyplot as plt
from scipy.stats import gaussian_kde

# Create comprehensive comparison plot
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), gridspec_kw={'height_ratios': [2, 1]})

# Top panel: Overlapping histograms with better bins
if "final_balances" in locals():
    # Use log-scale bins for better visualization
    all_balances = np.concatenate([final_balances, final_balances_mod])
    min_nonzero = np.min(all_balances[all_balances > 0])
    min_bin = min_nonzero if min_nonzero < 1 else 1
    max_bin = np.max(all_balances)*1.05
    bins = np.logspace(np.log10(min_bin), np.log10(max_bin), 35)
    
    # Histogram for modified strategy
    counts_mod, bins_edges, patches_mod = ax1.hist(final_balances_mod, bins=bins, 
                                                     alpha=0.5, label="Modified: Bet 50%", 
                                                     color="tab:blue", edgecolor='darkblue', 
                                                     linewidth=0.5)
    max_count_mod = max(counts_mod) if len(counts_mod) > 0 else 1
    for patch, count in zip(patches_mod, counts_mod):
        patch.set_facecolor(plt.cm.Blues(count/max_count_mod * 0.7))
    
    # Histogram for original strategy
    counts_orig, _, patches_orig = ax1.hist(final_balances, bins=bins, alpha=0.5, 
                                              label="Original: Bet 100%", color="tab:orange", 
                                              edgecolor='darkorange', linewidth=0.5)
    max_count_orig = max(counts_orig) if len(counts_orig) > 0 else 1
    for patch, count in zip(patches_orig, counts_orig):
        patch.set_facecolor(plt.cm.Oranges(count/max_count_orig * 0.7))
    
    ax1.set_xscale('log')
    ax1.axvline(initial_balance, linestyle='--', color='red', linewidth=2, label='Initial Balance')
    ax1.set_xlabel("Final Balance After 40 Years ($)")
    ax1.set_ylabel("Number of Simulations")
    ax1.set_title("Distribution of Final Balances: Original vs. Modified Strategy (Log Scale)")
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    # Format x-axis to show plain numbers instead of scientific notation
    ax1.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))
    # Set reasonable x-axis limits to show the data without excessive width
    ax1.set_xlim(left=min_nonzero if min_nonzero < 1 else 1, right=max_bin*1.5)
    # Rotate x-axis labels for better readability
    ax1.tick_params(axis='x', rotation=45)
    
    # Bottom panel: Box plot comparison
    box_data = [final_balances, final_balances_mod]
    bp = ax2.boxplot(box_data, labels=['Original\n100%', 'Modified\n50%'], 
                     patch_artist=True, widths=0.6)
    bp['boxes'][0].set_facecolor('tab:orange')
    bp['boxes'][1].set_facecolor('tab:blue')
    for element in ['whiskers', 'fliers', 'means', 'medians', 'caps']:
        plt.setp(bp[element], color='black', linewidth=1.2)
    ax2.set_yscale('log')
    ax2.set_ylabel("Final Balance (log scale)")
    ax2.set_title("Box Plot Comparison")
    ax2.grid(True, alpha=0.3, axis='y')
    # Format y-axis to show plain numbers instead of scientific notation
    ax2.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x:,.0f}'))

plt.tight_layout()
plt.show()

# Estimate probability of finishing above $30,000
prob_above_30000_mod = np.mean(final_balances_mod > initial_balance)
print(f"Estimated P(final balance > $30,000) [Modified, bet 50%/yr]: {prob_above_30000_mod:.3f}")

# Compare with original
if "prob_above_30000" in locals():
    print(f"Original strategy (bet 100%/yr): {prob_above_30000:.3f}")

# Brief visual/verbal comparison
mean_mod = np.mean(final_balances_mod)
median_mod = np.median(final_balances_mod)
print(
    f"""
Modified Strategy (bet 50% of balance per round):
- Mean final balance: ${mean_mod:,.2f}
- Median final balance: ${median_mod:,.2f}
- Fraction above $30,000: {prob_above_30000_mod:.1%}

For comparison, the original strategy (betting entire balance each round):
- Mean final balance: ${np.mean(final_balances):,.2f}
- Median final balance: ${np.median(final_balances):,.2f}
- Fraction above $30,000: {prob_above_30000:.1%}
"""
)

```

### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"
 
What is the Kelly Criterion and how does it relate to the modified strategy?

The **Kelly Criterion** is a mathematical formula that determines the optimal fraction of wealth to wager on a series of bets in order to maximize the long-run rate of wealth growth, while minimizing the risk of total ruin. In essence, it tells you not to "go all in", but rather to bet an exact, calculated slice of your capital each roundâ€”balancing reward against risk.

For a game like this, where each year you can win 50% or lose 40% of your bet, and the coin is fair, the Kelly formula for optimal fraction (`f*`) is:

$$
f^* = \frac{p}{b} - \frac{q}{a}
$$

Where:
- \( p \) = probability of a win (here, 0.5)
- \( q = 1-p \) = probability of a loss
- \( b \) = fraction won on a win (here, 50% gain, so 0.5)
- \( a \) = fraction lost on a loss (here, 40% loss, so 0.4)

Plugging in the numbers:
$$
f^* = \frac{0.5}{0.5} - \frac{0.5}{0.4} = 1 - 1.25 = -0.25
$$

But the correct form for games where you either multiply your bet by different factors (not simple win/lose on a bet size), the Kelly fraction simplifies to:

$$
f^* = \frac{p \cdot (b + 1) - 1}{b}
$$

In this game, after a bet of fraction $f$ of your wealth:
- If heads: $W_{t} = W_{t-1} \times (1 + 0.5 f)$
- If tails: $W_{t} = W_{t-1} \times (1 - 0.4 f)$
- $p = 0.5$

The Kelly fraction in this multiplicative case can be solved using:
$$
f^* = \underset{f}{\mathrm{argmax}}\ \mathbb{E}[\log(W_T)] 
$$
Or analytically:
$$
f^* = \frac{p}{d_1} - \frac{q}{d_2}
$$
with $d_1 = \frac{1}{0.5} = 2$, $d_2 = \frac{1}{0.4} = 2.5$, which results in $f^* \approx 50\%$.

**How it relates to our results:**

- The "bet everything" strategy (100% each time) is dramatically riskier than the Kelly-optimal fraction (about 50%). As our simulations showed, the all-in strategy resulted in high volatilityâ€”a few big wins, mostly total ruin.
- The "bet 50%"/Kelly-inspired strategy increased the probability of ending up above your starting balance and greatly reduced the risk of catastrophic loss.
- This illustrates the Kelly Criterion's core insight: _betting the mathematically optimal fraction maximizes your expected long-term growth, while betting more increases your chance of losing everything._

**Takeaway:**  
Risking only the Kelly amount is a powerful way to balance growth with safety. The modified strategy essentially put the Kelly Criterion into practice, producing outcomes that were safer and statistically superior to reckless full-risk betting.



:::: {.callout-note}
## Clear Narrative of the Investment Game

Imagine you are given the chance to play a repeated coin flip investment game: each year, you can double down, risking your entire fortune for either a 50% gain or a 40% loss, depending on whether the coin lands heads or tails. You start with \$30,000 and let it ride, flip after flip.

**At first glance, the game is tempting:**  
A simple expected value calculation after one flip shows a small gain over your starting amount. This lures many into thinking the strategy is a "good bet." But a deeper lookâ€”through simulation and applying the Kelly Criterionâ€”reveals a different story.

**Simulating reality** tells us that, although a handful of runs might end up with huge fortunes, the _majority_ of players will end up worse off than they started. The distribution is not symmetric: it is skewed, with few winners and many losers. In fact, most outcomes fall _below_ your original investment, and the average (mean) is pulled up by rare but massive wins.

**Why does this happen?**  
Because compounding volatility is brutal. Multiplicative risk means that a sequence of bad events can shrink your wealth dramatically, making it almost impossible to recoverâ€”even if the odds look good for a single play.

**What does the Kelly Criterion teach us?**  
The Kelly strategy tells you to risk only a portion of your wealth at every betâ€”balancing potential reward with the need to avoid catastrophic losses. In this game, betting about 50% (rather than 100%) each time shifts the odds dramatically in your favor: you greatly increase your chance of ending up ahead, and you avoid the near-certainty of eventual ruin that comes with all-in betting.

### **Bottom Line**

- **"Positive expected value" is not enough.** The _path_ matters: volatility and compounding destroy the security of simply chasing the mean.
- **Long-term investing isn't about bravadoâ€”it's about survival.** The optimal approach seeks growth, but never at the cost of risking everything.
- **The Kelly Criterion's wisdom:** To maximize long-term growth, take calculated risks, not maximal ones. Your future self will thank you.

This story is a cautionary tale for gamblers and investors alike: _Sound strategy beats reckless optimism, every time._

::: {.callout-warning}
### Key Insights and Practical Takeaways

- **Risk profile matters more than average outcome:**  
  Although the expected value after one flip is slightly positive, _the majority of players lose money over the long run_. This is because the game compounds multiplicative risksâ€”meaning a few bad years can wipe out most of your wealth, and rare big wins inflate the mean.

- **Counter-intuitive result: Most lose despite 'good odds':**  
  The typical investor finishes _with less than they started_, even though the game's expected value per flip is positive. The median outcome is *far below* the average. This highlights the dangers of relying solely on expected value and ignoring volatility.

- **Taming risk: Modified (Kelly) strategy drastically improves outcomes:**  
  Betting only half your wealth each round (the Kelly-optimal fraction) transforms the game's risk profile:  
  - **Probability of finishing above your starting balance increases substantially.**
  - Catastrophic losses become rareâ€”most outcomes cluster closer to the median.
  - Upside is still robust, but without the high likelihood of disastrous losses.

- **Practical implications:**  
  - In volatile, compounding games (or investments), survival matters most.
  - *Professional investors and gamblers* often use Kelly-like strategies to balance growth and safetyâ€”never going "all in."
  - _Positive expected value does not guarantee good results for most participants_: path and risk control are critical.

> **Bottom line for real decisions:**  
> Embrace strategies that control risk and avoid ruin. Optimize for long-term growth, not just short-term excitement or theoretical averages. Compounding favors caution and resilience over bravado.



::: {.callout-tip title="Human Interpretation: What Do These Results Mean for Real Decisions?"}

The simulation and analysis above underline a crucial lesson for anyone facing repeated-risk investment decisions:

- **Do not be deceived by positive expected value alone.**  
  While betting your entire balance might look attractive in a one-off scenario, over many rounds, the extreme volatility and multiplicative nature of returns mean that the vast majority of participants will lose moneyâ€”not gain it. The *path* your money takes matters as much as the average outcome.

- **Survival > Maximizing short-term gains.**  
  Long-term success in investing (or gambling) comes from *avoiding ruin*. Strategies that risk everything, even with favorable odds each round, almost guarantee eventual disaster over time.

- **Manage risk with smart strategies (like the Kelly Criterion).**  
  By risking only a fraction of your wealth on every bet, you dramatically increase your odds of finishing ahead. This doesn't just apply to casino gamesâ€”itâ€™s central to real-world investing, where **self-control and risk management** reliably beat reckless optimism.

**Practical takeaway for decision-making:**  
Always be wary of investments or strategies that compound risk aggressively, even if "the odds look good." Seek approaches that balance growth with staying powerâ€”because you can't win or grow wealth if you're knocked out of the game. In other words: optimize not just for possible reward, but also for minimizing the likelihood of catastrophic loss.

:::

:::

::::
